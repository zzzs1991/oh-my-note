### day2 

```markdown
day 2 代码加锁：不要让琐事成为烦心事
1. 使用synchronized关键字虽然简单，但是要弄清楚共享资源是实例级别的，还是类级别的。
	会被那些线程操作。
2. 加锁尽量考虑锁粒度和场景。
	- 尽量只为必要的代码加锁，降低锁的粒度。
	- 在性能要求高的场景，细化考虑锁的读写场景，以及悲观锁还是乐观锁优先
		考虑ReentrantReadWriteLock,StampedLock等高级工具类
3. 考虑可能遇到的死锁问题
	- 避免无限等待和循环等待
4. 如果业务逻辑中加锁的实现比较复杂，要仔细检查加锁和释放锁的可能性。
```

### day3

```markdown
day 3 线程池: 业务代码最常用也最容易犯错的组件
1. Excutors类提供的一些快捷声明线程池的方法，简单却埋坑，需要更具场景和需求合理配置线程池
2. 既然选择了线程池就要服用线程池，每次new一个线程池出来可能比不用线程池更糟糕。
3. 复用线程池不代表应用始终使用一个线程池，根据任务性质来选择不同的线程池。特别注意IO和Cpu绑定的任务。
4. 最好对线程池等核心组件进行监控
```

### day4

```markdown
day 4 连接池:别让连接池帮了倒忙
业务代码中最常用的三种连接池
    - redis连接池
    - HTTP连接池
    - 数据库连接池
1. 连接池的实现方式
    - 池和链接分离
    - 内部带有连接池
    - 非连接池
2. 使用姿势
    - 确保链接池是复用的
    - 尽可能在程序退出之前显式的关闭连接池释放资源
3. 连接池配置参数
    - 最重要的是最大链接数
```